{"ast":null,"code":"export const independentSelectStrategy = {\n  select: _ref => {\n    let {\n      id,\n      value,\n      mandatory,\n      selected\n    } = _ref;\n    selected.set(id, value ? 'on' : mandatory && !Array.from(selected.entries()).find(_ref2 => {\n      let [key, value] = _ref2;\n      return value === 'on' && key !== id;\n    }) ? 'on' : 'off');\n    return selected;\n  },\n  in: (v, children, parents) => {\n    let map = new Map();\n\n    for (const id of v || []) {\n      map = independentSelectStrategy.select({\n        id,\n        value: true,\n        selected: new Map(map),\n        children,\n        parents\n      });\n    }\n\n    return map;\n  },\n  out: v => {\n    const arr = [];\n\n    for (const [key, value] of v.entries()) {\n      if (value === 'on') arr.push(key);\n    }\n\n    return arr;\n  }\n};\nexport const independentSingleSelectStrategy = {\n  select: _ref3 => {\n    let {\n      id,\n      value,\n      ...rest\n    } = _ref3;\n    return independentSelectStrategy.select({ ...rest,\n      id,\n      value,\n      selected: new Map()\n    });\n  },\n  in: (v, children, parents) => {\n    let map = new Map();\n\n    if (v != null && v.length) {\n      map = independentSelectStrategy.in(v.slice(0, 1), children, parents);\n    }\n\n    return map;\n  },\n  out: (v, children, parents) => {\n    return independentSelectStrategy.out(v, children, parents);\n  }\n};\nexport const leafSelectStrategy = function () {\n  let single = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  const strategy = {\n    select: _ref4 => {\n      let {\n        id,\n        value,\n        selected,\n        children\n      } = _ref4;\n      if (children.has(id)) return selected;\n      if (single) return new Map([[id, value ? 'on' : 'off']]);\n      selected.set(id, value ? 'on' : 'off');\n      return selected;\n    },\n    in: (v, children, parents) => {\n      let map = new Map();\n\n      for (const id of v != null ? v : []) {\n        map = strategy.select({\n          id,\n          value: true,\n          selected: new Map(map),\n          children,\n          parents\n        });\n      }\n\n      return map;\n    },\n    out: independentSelectStrategy.out\n  };\n  return strategy;\n};\nexport const classicSelectStrategy = {\n  select: _ref5 => {\n    let {\n      id,\n      value,\n      selected,\n      children,\n      parents\n    } = _ref5;\n    const items = [id];\n\n    while (items.length) {\n      const item = items.shift();\n      selected.set(item, value ? 'on' : 'off');\n\n      if (children.has(item)) {\n        items.push(...children.get(item));\n      }\n    }\n\n    let parent = parents.get(id);\n\n    while (parent) {\n      const childrenIds = children.get(parent);\n      const everySelected = childrenIds.every(cid => selected.get(cid) === 'on');\n      const noneSelected = childrenIds.every(cid => !selected.has(cid) || selected.get(cid) === 'off');\n      selected.set(parent, everySelected ? 'on' : noneSelected ? 'off' : 'indeterminate');\n      parent = parents.get(parent);\n    }\n\n    return selected;\n  },\n  in: (v, children, parents) => {\n    let map = new Map();\n\n    for (const id of v || []) {\n      map = classicSelectStrategy.select({\n        id,\n        value: true,\n        selected: new Map(map),\n        children,\n        parents\n      });\n    }\n\n    return map;\n  },\n  out: (v, children) => {\n    const arr = [];\n\n    for (const [key, value] of v.entries()) {\n      if (value === 'on' && !children.has(key)) arr.push(key);\n    }\n\n    return arr;\n  }\n};","map":{"version":3,"mappings":"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","names":["independentSelectStrategy","select","_ref","id","value","mandatory","selected","set","Array","from","entries","find","_ref2","key","in","v","children","parents","map","Map","out","arr","push","independentSingleSelectStrategy","_ref3","rest","length","slice","leafSelectStrategy","single","strategy","_ref4","has","classicSelectStrategy","_ref5","items","item","shift","get","parent","childrenIds","everySelected","every","cid","noneSelected"],"sources":["../../../src/composables/nested/selectStrategies.ts"],"sourcesContent":["export type SelectStrategyFn = (data: {\n  id: string\n  value: boolean\n  selected: Map<string, 'on' | 'off' | 'indeterminate'>\n  children: Map<string, string[]>\n  parents: Map<string, string>\n  event?: Event\n  mandatory?: boolean\n}) => Map<string, 'on' | 'off' | 'indeterminate'>\n\nexport type SelectStrategyTransformInFn = (\n  v: string[] | undefined,\n  children: Map<string, string[]>,\n  parents: Map<string, string>\n) => Map<string, 'on' | 'off' | 'indeterminate'>\n\nexport type SelectStrategyTransformOutFn = (\n  v: Map<string, 'on' | 'off' | 'indeterminate'>,\n  children: Map<string, string[]>,\n  parents: Map<string, string>\n) => any[]\n\nexport type SelectStrategy = {\n  select: SelectStrategyFn\n  in: SelectStrategyTransformInFn\n  out: SelectStrategyTransformOutFn\n}\n\nexport const independentSelectStrategy: SelectStrategy = {\n  select: ({ id, value, mandatory, selected }) => {\n    selected.set(id, value ? 'on' : (\n      mandatory &&\n      !Array.from(selected.entries()).find(([key, value]) => value === 'on' && key !== id)\n    ) ? 'on' : 'off')\n\n    return selected\n  },\n  in: (v, children, parents) => {\n    let map = new Map()\n\n    for (const id of (v || [])) {\n      map = independentSelectStrategy.select({\n        id,\n        value: true,\n        selected: new Map(map),\n        children,\n        parents,\n      })\n    }\n\n    return map\n  },\n  out: v => {\n    const arr = []\n\n    for (const [key, value] of v.entries()) {\n      if (value === 'on') arr.push(key)\n    }\n\n    return arr\n  },\n}\n\nexport const independentSingleSelectStrategy: SelectStrategy = {\n  select: ({ id, value, ...rest }) => {\n    return independentSelectStrategy.select({ ...rest, id, value, selected: new Map() })\n  },\n  in: (v, children, parents) => {\n    let map = new Map()\n\n    if (v?.length) {\n      map = independentSelectStrategy.in(v.slice(0, 1), children, parents)\n    }\n\n    return map\n  },\n  out: (v, children, parents) => {\n    return independentSelectStrategy.out(v, children, parents)\n  },\n}\n\nexport const leafSelectStrategy = (single = false): SelectStrategy => {\n  const strategy: SelectStrategy = {\n    select: ({ id, value, selected, children }) => {\n      if (children.has(id)) return selected\n\n      if (single) return new Map([[id, value ? 'on' : 'off']])\n\n      selected.set(id, value ? 'on' : 'off')\n\n      return selected\n    },\n    in: (v, children, parents) => {\n      let map = new Map()\n\n      for (const id of (v ?? [])) {\n        map = strategy.select({\n          id,\n          value: true,\n          selected: new Map(map),\n          children,\n          parents,\n        })\n      }\n\n      return map\n    },\n    out: independentSelectStrategy.out,\n  }\n\n  return strategy\n}\n\nexport const classicSelectStrategy: SelectStrategy = {\n  select: ({ id, value, selected, children, parents }) => {\n    const items = [id]\n\n    while (items.length) {\n      const item = items.shift()!\n\n      selected.set(item, value ? 'on' : 'off')\n\n      if (children.has(item)) {\n        items.push(...children.get(item)!)\n      }\n    }\n\n    let parent = parents.get(id)\n\n    while (parent) {\n      const childrenIds = children.get(parent)!\n      const everySelected = childrenIds.every(cid => selected.get(cid) === 'on')\n      const noneSelected = childrenIds.every(cid => !selected.has(cid) || selected.get(cid) === 'off')\n\n      selected.set(parent, everySelected ? 'on' : noneSelected ? 'off' : 'indeterminate')\n\n      parent = parents.get(parent)\n    }\n\n    return selected\n  },\n  in: (v, children, parents) => {\n    let map = new Map()\n\n    for (const id of (v || [])) {\n      map = classicSelectStrategy.select({\n        id,\n        value: true,\n        selected: new Map(map),\n        children,\n        parents,\n      })\n    }\n\n    return map\n  },\n  out: (v, children) => {\n    const arr = []\n\n    for (const [key, value] of v.entries()) {\n      if (value === 'on' && !children.has(key)) arr.push(key)\n    }\n\n    return arr\n  },\n}\n"]},"metadata":{},"sourceType":"module"}